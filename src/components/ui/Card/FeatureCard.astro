---
// Props tipadas
interface Props {
  title: string;
  description: string;
  icon: string; // SVG string o slot
  colSpan?: string; // Tailwind col-span
}

const { title, description, icon, colSpan = "col-span-1 md:col-span-1" } = Astro.props;
---

<div class={`feature-card bg-muga-dark-800/50 ${colSpan} p-6 flex flex-col border border-white/5`}>
  <div class="light-effect"></div>
  <div class="flex items-center mb-4">
    <div class="w-10 h-10 rounded-full bg-accent/20 flex items-center justify-center mr-3" aria-hidden="true">
      <Fragment set:html={icon} />
    </div>
    <h3 class="text-lg font-medium text-white">{title}</h3>
  </div>
  <p class="text-muga-neutral">{description}</p>
</div>

<style>
  /* Efecto hover en las tarjetas de características */
  .feature-card {
    position: relative;
    transition: border-color 0.3s ease;
    overflow: hidden;
  }
  
  /* Efecto de luz dentro de cada tarjeta */
  .light-effect {
    position: absolute;
    width: 150px;
    height: 150px;
    border-radius: 50%;
    background: rgba(255, 83, 83, 0.5); /* accent/20 */
    pointer-events: none;
    filter: blur(100px);
    opacity: 0;
    z-index: 1;
    transition: opacity 0.3s ease;
  }
  
  /* Aseguramos que el contenido esté por encima del efecto de luz */
  .feature-card > *:not(.light-effect) {
    position: relative;
    z-index: 2;
  }
</style>

<script>
  document.addEventListener("astro:page-load", () => {
    // Definir interfaces para TypeScript
    interface HTMLElementWithStyle extends HTMLElement {
      style: CSSStyleDeclaration;
    }
    
    interface LightEffectElement extends HTMLElementWithStyle {
      style: CSSStyleDeclaration & {
        opacity: string;
        left: string;
        top: string;
        transform: string;
      };
    }
    
    interface FeatureCardElement extends HTMLElementWithStyle {
      style: CSSStyleDeclaration & {
        borderImage: string;
      };
    }

    // Seleccionamos los elementos y los tipamos
    const featureCards = document.querySelectorAll<FeatureCardElement>(".feature-card");
    
    // Usar variables CSS para mejor rendimiento
    document.documentElement.style.setProperty('--light-opacity', '0');
    
    // Optimización 1: Usar throttle para limitar la frecuencia de eventos mousemove
    function throttle(callback: Function, limit: number) {
      let waiting = false;
      return function(this: any, ...args: any[]) {
        if (!waiting) {
          callback.apply(this, args);
          waiting = true;
          setTimeout(() => {
            waiting = false;
          }, limit);
        }
      };
    }

    featureCards.forEach((card) => {
      const lightEffect = card.querySelector<LightEffectElement>(".light-effect");
      
      // Optimización 2: Usar mouseenter/mouseleave en lugar de mouseover/mouseout
      card.addEventListener("mouseenter", () => {
        if (lightEffect) {
          // Optimización 3: Usar CSS variables para animaciones más fluidas
          document.documentElement.style.setProperty('--light-opacity', '1');
          lightEffect.style.opacity = "1";
        }
      });

      card.addEventListener("mouseleave", () => {
        if (lightEffect) {
          document.documentElement.style.setProperty('--light-opacity', '0');
          lightEffect.style.opacity = "0";
        }
        card.style.borderImage = "none";
      });

      // Optimización 4: Throttle para el evento mousemove (limitar a 30ms)
      card.addEventListener("mousemove", throttle((e: MouseEvent) => {
        const rect = card.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (lightEffect) {
          // Optimización 5: Usar transform para mejor rendimiento
          lightEffect.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%)`;
        }

        // Optimización 6: Precalcular valores y reutilizar
        const gradientSize = 153;
        const borderGradient = `
          radial-gradient(
            circle ${gradientSize}px at ${x}px ${y}px,
            rgba(255, 83, 83, 0.5) 50%,
            rgba(255, 255, 255, 0.05) ${gradientSize}px
          ) 1
        `;

        // Optimización 7: Usar requestAnimationFrame para cambios visuales
        requestAnimationFrame(() => {
          card.style.borderImage = borderGradient;
        });
      }, 30));
    });
  });
</script>